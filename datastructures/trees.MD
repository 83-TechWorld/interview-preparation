excellent ğŸŒ³ â€” now weâ€™re stepping into one of the most conceptually rich parts of DSA: **Binary Trees & Binary Search Trees (BSTs)**.

trees are everywhere â€” compilers, file systems, databases, and AI models (like decision trees).

weâ€™ll go through **14 important problems**, grouped naturally by category.
for each one youâ€™ll get ğŸ‘‡

âœ… the problem statement
ğŸ§± what data structure is used
ğŸ§  how the algorithm works
ğŸ” how to debug it step-by-step
ğŸ’» fully commented java code
âš™ï¸ complexity

---

# ğŸŒ³ What is a Binary Tree?

A **Binary Tree** is a hierarchical data structure made of nodes.
Each node has:

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}
```

ğŸ”¹ **Root:** topmost node
ğŸ”¹ **Left/Right Child:** pointers to subtrees
ğŸ”¹ **Leaf:** node with no children

---

# ğŸŒ¿ What is a Binary Search Tree (BST)?

A **BST** is a *special* binary tree with this property:

```
For every node:
  left subtree < node < right subtree
```

Thatâ€™s why BSTs are great for **searching, inserting, deleting** efficiently (`O(log n)` on average).

---

# ğŸ§© Debugging Tips for Tree Problems

âœ… Always **draw a small example** tree (4â€“5 nodes).
âœ… Track recursive calls carefully.
âœ… Print logs like `System.out.println("At node: " + node.val);`
âœ… For BFS (Level Order) â†’ visualize queue content.
âœ… For recursion â†’ note what each return means.

---

# ğŸŒ² 1. Invert Binary Tree

### ğŸ§© Problem

Swap the left and right children of every node.

**Example:**

```
Input:      Output:
   4           4
  / \         / \
 2   7  â†’    7   2
/ \ / \     / \ / \
1 3 6 9   9 6 3 1
```

### ğŸ§± Data Structure

Binary Tree (recursive traversal)

### ğŸ§  Approach

Use recursion:

* swap left and right recursively.

### ğŸ’» Java Code

```java
class InvertBinaryTree {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        // swap
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);

        return root;
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print node value before and after swap.

---

# ğŸŒ² 2. Maximum Depth of Binary Tree

### ğŸ§© Problem

Find the maximum depth (longest path from root to leaf).

### ğŸ§± Data Structure

Binary Tree

### ğŸ§  Approach

Recursively compute:
`maxDepth(root) = 1 + max(depth(left), depth(right))`

### ğŸ’» Code

```java
class MaxDepth {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print depth returned at each node.

---

# ğŸŒ² 3. Same Tree

### ğŸ§© Problem

Check if two trees are identical in structure and values.

### ğŸ§  Approach

If both null â†’ true
If one null â†’ false
Else check value + recursively check children.

### ğŸ’» Code

```java
class SameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print pairs of compared nodes.

---

# ğŸŒ² 4. Subtree of Another Tree

### ğŸ§© Problem

Check if tree `t` is a subtree of `s`.

### ğŸ§  Approach

At each node of `s`, check if `s` and `t` are same trees.

### ğŸ’» Code

```java
class SubtreeOfAnotherTree {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null) return false;
        if (isSameTree(s, t)) return true;
        return isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private boolean isSameTree(TreeNode a, TreeNode b) {
        if (a == null && b == null) return true;
        if (a == null || b == null || a.val != b.val) return false;
        return isSameTree(a.left, b.left) && isSameTree(a.right, b.right);
    }
}
```

### âš™ï¸ O(n * m)

**Debug Tip:** print whenever new subtree comparison starts.

---

# ğŸŒ² 5. Lowest Common Ancestor (LCA) of a BST

### ğŸ§© Problem

Find lowest node that is ancestor of both `p` and `q`.

**Example:**

```
      6
     / \
    2   8
   / \ / \
  0  4 7 9
     / \
    3  5

LCA(2,8)=6; LCA(2,4)=2
```

### ğŸ§± Data Structure

Binary Search Tree (BST)

### ğŸ§  Approach

* If both values < root â†’ move left
* If both > root â†’ move right
* Else current node = LCA

### ğŸ’» Code

```java
class LCAofBST {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (root != null) {
            if (p.val < root.val && q.val < root.val)
                root = root.left;
            else if (p.val > root.val && q.val > root.val)
                root = root.right;
            else
                return root; // split point
        }
        return null;
    }
}
```

### âš™ï¸ O(h)

**Debug Tip:** trace values of root, p, q at each iteration.

---

# ğŸŒ² 6. Binary Tree Level Order Traversal

### ğŸ§© Problem

Return node values **level by level** (BFS).

### ğŸ§± Data Structure

Use **Queue (FIFO)** for breadth-first search.

### ğŸ’» Code

```java
import java.util.*;

class LevelOrderTraversal {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            int size = q.size();
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                level.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print queue content each level.

---

# ğŸŒ² 7. Validate Binary Search Tree

### ğŸ§© Problem

Check if given tree follows BST property.

### ğŸ§  Approach

Recursively check if each node value lies within `(min, max)` bounds.

### ğŸ’» Code

```java
class ValidateBST {
    public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean validate(TreeNode node, long min, long max) {
        if (node == null) return true;
        if (node.val <= min || node.val >= max) return false;
        return validate(node.left, min, node.val) &&
               validate(node.right, node.val, max);
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** log min and max range per node.

---

# ğŸŒ² 8. Kth Smallest Element in a BST

### ğŸ§© Problem

Find the `k`-th smallest element in a BST.

### ğŸ§  Approach

Use **Inorder Traversal** (Left â†’ Root â†’ Right) â†’ returns sorted order.
Stop when k == 0.

### ğŸ’» Code

```java
class KthSmallestBST {
    private int count, result;

    public int kthSmallest(TreeNode root, int k) {
        count = k;
        inorder(root);
        return result;
    }

    private void inorder(TreeNode node) {
        if (node == null) return;
        inorder(node.left);
        count--;
        if (count == 0) {
            result = node.val;
            return;
        }
        inorder(node.right);
    }
}
```

### âš™ï¸ O(h + k)

**Debug Tip:** print value and k on each visit.

---

# ğŸŒ² 9. Construct Binary Tree from Preorder and Inorder Traversal

### ğŸ§© Problem

Given preorder & inorder arrays, rebuild the binary tree.

**Example:**
`preorder = [3,9,20,15,7]`
`inorder = [9,3,15,20,7]`

### ğŸ§  Approach

* Preorder gives **root first**.
* Inorder splits into left & right subtrees.

Use recursion:

* Pick root from preorder
* Split inorder
* Recurse left/right

### ğŸ’» Code

```java
import java.util.*;

class BuildTree {
    private Map<Integer, Integer> inorderMap;
    private int preIndex = 0;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        return helper(preorder, 0, inorder.length - 1);
    }

    private TreeNode helper(int[] preorder, int left, int right) {
        if (left > right) return null;

        int rootVal = preorder[preIndex++];
        TreeNode root = new TreeNode(rootVal);

        int mid = inorderMap.get(rootVal);
        root.left = helper(preorder, left, mid - 1);
        root.right = helper(preorder, mid + 1, right);

        return root;
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print preorder index and inorder split range.

---

# ğŸŒ² 10. Binary Tree Maximum Path Sum

### ğŸ§© Problem

Find maximum path sum (any path connecting two nodes).

### ğŸ§  Approach

For each node, compute:
`max_gain = node.val + max(0, left_gain, right_gain)`
Keep global max for `left + node + right`.

### ğŸ’» Code

```java
class MaxPathSum {
    private int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        gain(root);
        return maxSum;
    }

    private int gain(TreeNode node) {
        if (node == null) return 0;
        int left = Math.max(gain(node.left), 0);
        int right = Math.max(gain(node.right), 0);

        maxSum = Math.max(maxSum, node.val + left + right);
        return node.val + Math.max(left, right);
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print gain and global max at each node.

---

# ğŸŒ² 11. Serialize and Deserialize Binary Tree

### ğŸ§© Problem

Convert tree â†’ string and back.

### ğŸ§± Data Structure

Queue for level-order (BFS) approach.

### ğŸ’» Code

```java
import java.util.*;

class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "null";
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        StringBuilder sb = new StringBuilder();

        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            if (node == null) {
                sb.append("null,");
                continue;
            }
            sb.append(node.val).append(",");
            q.offer(node.left);
            q.offer(node.right);
        }
        return sb.toString();
    }

    public TreeNode deserialize(String data) {
        if (data.equals("null")) return null;
        String[] vals = data.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        int i = 1;
        while (!q.isEmpty() && i < vals.length) {
            TreeNode node = q.poll();
            if (!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                q.offer(node.left);
            }
            i++;
            if (!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                q.offer(node.right);
            }
            i++;
        }
        return root;
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print string before/after deserialization.

---

# ğŸŒ² 12. Balanced Binary Tree

### ğŸ§© Problem

Check if treeâ€™s left & right subtrees differ in height â‰¤ 1.

### ğŸ§  Approach

Recursive:

* compute height of each subtree
* if abs difference > 1 â†’ unbalanced

### ğŸ’» Code

```java
class BalancedBinaryTree {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }

    private int height(TreeNode node) {
        if (node == null) return 0;
        int left = height(node.left);
        int right = height(node.right);
        if (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;
        return 1 + Math.max(left, right);
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print height at each node.

---

# ğŸŒ² 13. Count Complete Tree Nodes

### ğŸ§© Problem

Count total nodes in a complete binary tree.

### ğŸ§± Data Structure

Binary Tree (special case: perfect tree subtrees)

### ğŸ§  Approach

If left and right subtree heights are equal â†’ subtree is perfect:
`nodes = 2^height - 1`, else count recursively.

### ğŸ’» Code

```java
class CountCompleteTreeNodes {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        int left = leftHeight(root);
        int right = rightHeight(root);
        if (left == right) return (1 << left) - 1;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }

    private int leftHeight(TreeNode node) {
        int h = 0;
        while (node != null) {
            h++;
            node = node.left;
        }
        return h;
    }

    private int rightHeight(TreeNode node) {
        int h = 0;
        while (node != null) {
            h++;
            node = node.right;
        }
        return h;
    }
}
```

### âš™ï¸ O((log n)Â²)

**Debug Tip:** print left/right heights at each step.

---

# ğŸŒ² 14. Binary Tree Right Side View

### ğŸ§© Problem

Return nodes visible from the right side.

**Example:**

```
Input: [1,2,3,null,5,null,4]
Output: [1,3,4]
```

### ğŸ§  Approach

BFS level order â†’ take **last node** of each level.

### ğŸ’» Code

```java
import java.util.*;

class RightSideView {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                if (i == size - 1) result.add(node.val); // rightmost
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
        }
        return result;
    }
}
```

### âš™ï¸ O(n)

**Debug Tip:** print nodes in each level.

---

## ğŸ§© Summary Table â€” Tree Problems

| #  | Problem               | Type        | Approach                   | DS Used         | Time        | Debug Tip             |
| -- | --------------------- | ----------- | -------------------------- | --------------- | ----------- | --------------------- |
| 1  | Invert Tree           | Binary Tree | Swap children recursively  | Recursion       | O(n)        | Print before swap     |
| 2  | Max Depth             | Binary Tree | DFS depth                  | Recursion       | O(n)        | Print depth           |
| 3  | Same Tree             | Binary Tree | Compare recursively        | Recursion       | O(n)        | Print compared pairs  |
| 4  | Subtree               | Binary Tree | Check each node as root    | Recursion       | O(n*m)      | Log subtree roots     |
| 5  | LCA of BST            | BST         | Property-based traversal   | BST             | O(h)        | Track current root    |
| 6  | Level Order           | Binary Tree | BFS                        | Queue           | O(n)        | Print queue per level |
| 7  | Validate BST          | BST         | Range recursion            | Recursion       | O(n)        | Log min/max           |
| 8  | Kth Smallest          | BST         | Inorder traversal          | Stack/Recursion | O(k)        | Log visited values    |
| 9  | Construct Tree        | Binary Tree | Build via preorder/inorder | Recursion + Map | O(n)        | Print preorder index  |
| 10 | Max Path Sum          | Binary Tree | DFS + global max           | Recursion       | O(n)        | Log gains             |
| 11 | Serialize/Deserialize | Binary Tree | BFS encode/decode          | Queue           | O(n)        | Print encoded data    |
| 12 | Balanced Tree         | Binary Tree | Height diff â‰¤ 1            | Recursion       | O(n)        | Print heights         |
| 13 | Count Complete        | Binary Tree | Height comparison          | Recursion       | O((log n)Â²) | Print heights         |
| 14 | Right Side View       | Binary Tree | BFS â†’ last per level       | Queue           | O(n)        | Print per level       |

---