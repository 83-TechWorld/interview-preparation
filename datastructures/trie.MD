awesome ğŸŒŸ â€” youâ€™re now entering one of the coolest and most **interview-loved data structures**:

# âœ¨ **Tries (Prefix Trees)**

letâ€™s go step-by-step, from basics â†’ implementation â†’ real-world cases â†’ solving 3 classic problems.

---

## ğŸŒ³ What is a Trie?

A **Trie** (pronounced â€œtryâ€) is a *prefix tree* â€” a tree-like data structure used to **store and search strings efficiently**, especially when many strings share common prefixes.

each node:

* represents one **character**
* connects to children (possible next characters)
* may mark the **end of a valid word**

---

### ğŸ§± Trie Node Structure

in java, we usually define:

```java
class TrieNode {
    TrieNode[] children = new TrieNode[26]; // for 'a' to 'z'
    boolean isEndOfWord = false;
}
```

---

### ğŸ” Visualization

letâ€™s store: `"cat"`, `"car"`, `"dog"`

```
(root)
 â”œâ”€â”€ c
 â”‚    â””â”€â”€ a
 â”‚         â”œâ”€â”€ t (end)
 â”‚         â””â”€â”€ r (end)
 â””â”€â”€ d
      â””â”€â”€ o
           â””â”€â”€ g (end)
```

---

## âš™ï¸ When to Use a Trie

âœ… Searching or autocompleting prefixes fast
âœ… Dictionary word lookups
âœ… Spell checkers
âœ… Word games (like Boggle, Word Search)
âœ… IP routing tables
âœ… Search suggestions (like â€œgâ€ â†’ â€œgoogleâ€, â€œgmailâ€)

---

## ğŸ’» Basic Operations

| Operation     | Time Complexity | Description                                  |
| ------------- | --------------- | -------------------------------------------- |
| Insert word   | O(L)            | L = word length                              |
| Search word   | O(L)            | check if exists                              |
| Prefix search | O(L)            | check if prefix exists                       |
| Delete word   | O(L)            | recursively remove nodes if no longer needed |

---

# ğŸ§© Problem 1 â€” Implement Trie (Prefix Tree)

### ğŸ§© Problem

Design a Trie with operations:

* `insert(word)`
* `search(word)`
* `startsWith(prefix)`

---

### ğŸ§  Idea

use a root node (empty).
for each char in a word:

* if node doesnâ€™t exist â†’ create it
* move to next
  when end reached â†’ mark `isEndOfWord = true`

---

### ğŸ’» Java Code

```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEndOfWord = false;
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Insert a word
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEndOfWord = true;
    }

    // Search full word
    public boolean search(String word) {
        TrieNode node = findNode(word);
        return node != null && node.isEndOfWord;
    }

    // Check if prefix exists
    public boolean startsWith(String prefix) {
        return findNode(prefix) != null;
    }

    // Helper
    private TrieNode findNode(String s) {
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) return null;
            node = node.children[idx];
        }
        return node;
    }
}
```

---

### âš™ï¸ Complexity

* Insert/Search/Prefix: `O(L)` (L = word length)
* Space: `O(26 * N * avgLen)` worst case

---

### ğŸ§­ Debugging Tips

* print the traversal path of characters
* log when new nodes are created or existing reused
* check for off-by-one in char index (`c - 'a'`)

---

### ğŸ¯ Real-World Example

* Autocomplete: `startsWith("go")` â†’ ["good", "google", "golf"]
* Spell checker: `search("aple")` â†’ false

---

# ğŸ§© Problem 2 â€” Design Add and Search Words Data Structure

*(Word Dictionary)*

### ğŸ§© Problem

Implement a data structure that supports:

* `addWord(word)`
* `search(pattern)` â€” where `pattern` can include `.` meaning *any character.*

**Example:**

```
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") â†’ false
search("bad") â†’ true
search(".ad") â†’ true
search("b..") â†’ true
```

---

### ğŸ§  Core Idea

This is similar to `Trie`, but searching must handle wildcards (`.`).
If `.` found â†’ try **all child nodes recursively.**

---

### ğŸ’» Java Code

```java
class WordDictionary {
    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }

    public void addWord(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null)
                node.children[idx] = new TrieNode();
            node = node.children[idx];
        }
        node.isEndOfWord = true;
    }

    public boolean search(String word) {
        return searchHelper(word, 0, root);
    }

    private boolean searchHelper(String word, int index, TrieNode node) {
        if (index == word.length()) return node.isEndOfWord;

        char c = word.charAt(index);
        if (c == '.') {
            // try all possibilities
            for (TrieNode child : node.children) {
                if (child != null && searchHelper(word, index + 1, child))
                    return true;
            }
            return false;
        } else {
            int idx = c - 'a';
            if (node.children[idx] == null) return false;
            return searchHelper(word, index + 1, node.children[idx]);
        }
    }
}
```

---

### âš™ï¸ Complexity

* Insert: `O(L)`
* Search: Worst `O(26^L)` if many wildcards
* Average much less

---

### ğŸ§­ Debugging Tips

* Print recursion depth and current prefix
* Trace wildcard branches visually

---

### ğŸ¯ Real-World Analogy

* Search bar with partial or fuzzy matching
* Regex engine simplified for word lookups

---

# ğŸ§© Problem 3 â€” Word Search II

*(Uses Trie for optimization)*

### ğŸ§© Problem

Given a board of letters and a list of words, find all words that exist in the grid.

Each word must be formed by **adjacent letters (up/down/left/right)** and canâ€™t reuse the same cell twice.

**Example:**

```
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]

Output: ["oath","eat"]
```

---

### ğŸ§± Data Structures

* **Trie** â†’ store all words for prefix lookup
* **DFS (Depth-First Search)** â†’ explore board

---

### ğŸ§  Approach

1ï¸âƒ£ Build Trie from all `words`
2ï¸âƒ£ For each board cell:

* DFS to explore neighbors
* stop early if prefix not found in Trie
  3ï¸âƒ£ Mark visited cells temporarily
  4ï¸âƒ£ Collect words when `isEndOfWord=true`

---

### ğŸ’» Java Code

```java
import java.util.*;

class WordSearchII {
    private Set<String> result = new HashSet<>();
    private int rows, cols;
    private TrieNode root;

    public List<String> findWords(char[][] board, String[] words) {
        // 1ï¸âƒ£ Build Trie
        root = new TrieNode();
        for (String w : words) insert(w);

        rows = board.length;
        cols = board[0].length;

        // 2ï¸âƒ£ DFS from each cell
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                dfs(board, i, j, root, "");
            }
        }
        return new ArrayList<>(result);
    }

    private void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null)
                node.children[idx] = new TrieNode();
            node = node.children[idx];
        }
        node.isEndOfWord = true;
    }

    private void dfs(char[][] board, int i, int j, TrieNode node, String word) {
        if (i < 0 || i >= rows || j < 0 || j >= cols || board[i][j] == '#')
            return;

        char c = board[i][j];
        TrieNode next = node.children[c - 'a'];
        if (next == null) return; // no prefix match

        word += c;
        if (next.isEndOfWord) result.add(word);

        board[i][j] = '#'; // mark visited
        dfs(board, i + 1, j, next, word);
        dfs(board, i - 1, j, next, word);
        dfs(board, i, j + 1, next, word);
        dfs(board, i, j - 1, next, word);
        board[i][j] = c; // backtrack
    }
}
```

---

### âš™ï¸ Complexity

* Building Trie: `O(W * L)`
* DFS: up to `O(M * N * 4^L)`
* With Trie pruning: much faster in practice

---

### ğŸ§­ Debugging Tips

* Print prefix path in DFS
* Watch for visited cells (`#`)
* Verify when backtracking restores original char

---

### ğŸ¯ Real-World Use Case

* Word puzzle solver (like Boggle or crossword)
* Autocomplete with spatial constraints
* AI for word games

---

## ğŸ§© Summary Table â€” Trie Problems

| # | Problem           | Key Operation            | DS Used          | Idea               | Time          | Real Analogy          |
| - | ----------------- | ------------------------ | ---------------- | ------------------ | ------------- | --------------------- |
| 1 | Implement Trie    | Insert, search, prefix   | Trie             | Character tree     | O(L)          | Autocomplete          |
| 2 | Add & Search Word | Search with '.' wildcard | Trie + Recursion | DFS search for '.' | O(26^L) worst | Regex-like dictionary |
| 3 | Word Search II    | Word discovery in grid   | Trie + DFS       | Prefix pruning     | O(MNÂ·4^L)     | Crossword solver      |

---

### ğŸŒŸ Key Takeaways

* **Trie** is the go-to data structure for **prefix-based** search.
* Its biggest strength: **prefix pruning** â€” avoids redundant work.
* Combining **Trie + DFS** = magic for word problems.
* Mastering it helps you with **autocomplete systems, spell checkers, and AI assistants.**

---
