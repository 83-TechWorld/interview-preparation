awesome âš™ï¸ â€” youâ€™ve mastered trees and tries, and now weâ€™re stepping into another powerful structure used everywhere from **search engines** to **task schedulers**:

# ğŸš€ **Heap / Priority Queue (4 Classic Problems)**

youâ€™ll learn:
âœ… what a heap really is
âœ… when & why to use it
âœ… java implementation details (`PriorityQueue`)
âœ… step-by-step debugging flow
âœ… full commented java code

---

## ğŸ§± What Is a Heap (Priority Queue)?

A **Heap** is a **complete binary tree** that satisfies the **heap property**:

* **Min-Heap** â†’ every parent â‰¤ its children (smallest at root)
* **Max-Heap** â†’ every parent â‰¥ its children (largest at root)

In Java, this is implemented using the **`PriorityQueue`** class.

### ğŸ’¡ Default Behavior:

```java
PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap
PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder()); // max-heap
```

| Operation          | Time Complexity | Description     |
| ------------------ | --------------- | --------------- |
| insert (offer/add) | O(log n)        | Add new element |
| remove top (poll)  | O(log n)        | Remove min/max  |
| peek               | O(1)            | View min/max    |

---

# ğŸ§© 1ï¸âƒ£ Kth Largest Element in an Array

### ğŸ§© Problem

Find the **k-th largest** element in an unsorted array.

**Example:**
`nums = [3,2,1,5,6,4], k=2` â†’ **5**

---

### ğŸ¯ Real-life analogy

Leaderboard ranking â†’ find 2nd highest score efficiently.

---

### ğŸ§  Core Idea

Maintain a **min-heap** of size `k`:

* push elements
* if heap size > k â†’ pop smallest
* after all â†’ top = kth largest

---

### ğŸ’» Java Code

```java
import java.util.*;

class KthLargestElement {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int n : nums) {
            minHeap.offer(n);
            if (minHeap.size() > k) {
                minHeap.poll(); // remove smallest
            }
        }
        return minHeap.peek(); // kth largest
    }
}
```

---

### ğŸ” Debug Step-by-Step

```
nums = [3,2,1,5,6,4], k=2
heap: [3]
heap: [2,3]
heap: [3] (removed 2)
heap: [3,5]
heap: [5,6]
heap: [5,6,4] â†’ remove smallest â†’ [5,6]
peek = 5 âœ…
```

---

### âš™ï¸ Complexity

* Time: O(n log k)
* Space: O(k)

**Debug Tip:** print heap contents after each insertion.

---

# ğŸ§© 2ï¸âƒ£ Top K Frequent Elements

### ğŸ§© Problem

Given a list of integers, return the `k` most frequent elements.

**Example:**
`nums = [1,1,1,2,2,3], k = 2` â†’ `[1,2]`

---

### ğŸ¯ Real-life analogy

Track **most searched keywords** or **most used hashtags**.

---

### ğŸ§  Core Idea

1ï¸âƒ£ Count frequency using a **HashMap**
2ï¸âƒ£ Use a **min-heap** to keep top `k` frequent numbers

* heap ordered by frequency
* if size > k â†’ remove smallest frequency

---

### ğŸ’» Java Code

```java
import java.util.*;

class TopKFrequentElements {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int n : nums)
            freq.put(n, freq.getOrDefault(n, 0) + 1);

        PriorityQueue<Map.Entry<Integer, Integer>> minHeap =
            new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());

        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            minHeap.offer(entry);
            if (minHeap.size() > k) minHeap.poll();
        }

        int[] result = new int[k];
        for (int i = k - 1; i >= 0; i--)
            result[i] = minHeap.poll().getKey();

        return result;
    }
}
```

---

### ğŸ” Debug Example

```
nums = [1,1,1,2,2,3], k=2
freq = {1:3, 2:2, 3:1}
heap after processing:
[1:3, 2:2] â†’ remove smallest â†’ keep top 2 â†’ [1,2]
output = [1,2]
```

---

### âš™ï¸ Complexity

* Time: O(n log k)
* Space: O(n)

**Debug Tip:** log `(element, freq)` pairs in heap at each step.

---

# ğŸ§© 3ï¸âƒ£ Merge K Sorted Lists

### ğŸ§© Problem

Merge `k` sorted linked lists into one sorted list.

**Example:**

```
Input:
1â†’4â†’5,
1â†’3â†’4,
2â†’6
Output: 1â†’1â†’2â†’3â†’4â†’4â†’5â†’6
```

---

### ğŸ§± Data Structure

* **Min-Heap** â†’ store smallest head among lists.

---

### ğŸ§  Core Idea

1ï¸âƒ£ Push first node of each list into heap
2ï¸âƒ£ Pop smallest node
3ï¸âƒ£ Append to merged list
4ï¸âƒ£ Push its `next` node into heap

---

### ğŸ’» Java Code

```java
import java.util.*;

class MergeKSortedLists {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            (a, b) -> a.val - b.val
        );

        for (ListNode node : lists)
            if (node != null) pq.offer(node);

        ListNode dummy = new ListNode(0), tail = dummy;

        while (!pq.isEmpty()) {
            ListNode node = pq.poll();
            tail.next = node;
            tail = tail.next;
            if (node.next != null) pq.offer(node.next);
        }

        return dummy.next;
    }
}
```

---

### ğŸ” Debug Example

```
heap: [1(list1), 1(list2), 2(list3)]
poll â†’ 1 â†’ push next(4)
heap: [1,2,4]
poll â†’ 1 â†’ push next(3)
heap: [2,3,4]
poll â†’ 2 â†’ push next(6)
...
```

---

### âš™ï¸ Complexity

* Time: O(N log K) (N = total nodes)
* Space: O(K)

**Debug Tip:** print heap.peek() each iteration.

---

### ğŸ¯ Real-world Analogy

* Merging multiple **sorted logs** or **database cursors** efficiently.
* File merging during **external sorting**.

---

# ğŸ§© 4ï¸âƒ£ Find Median from Data Stream

### ğŸ§© Problem

Design a data structure to **add numbers** and **find median** efficiently.

**Example:**

```
add(1)
add(2)
findMedian() â†’ 1.5
add(3)
findMedian() â†’ 2.0
```

---

### ğŸ§± Data Structure

Two Heaps:

* **Max-Heap** â†’ left half (smaller numbers)
* **Min-Heap** â†’ right half (larger numbers)

Balance both so that:

* sizes differ â‰¤ 1
* median = avg(peek(left), peek(right)) if even
* median = peek(left) if odd

---

### ğŸ§  Core Idea

Insert new number:

* if smaller â†’ maxHeap
* else â†’ minHeap
  Then **rebalance**.

---

### ğŸ’» Java Code

```java
import java.util.*;

class MedianFinder {
    private PriorityQueue<Integer> leftMax; // smaller half
    private PriorityQueue<Integer> rightMin; // larger half

    public MedianFinder() {
        leftMax = new PriorityQueue<>(Collections.reverseOrder());
        rightMin = new PriorityQueue<>();
    }

    public void addNum(int num) {
        if (leftMax.isEmpty() || num <= leftMax.peek())
            leftMax.offer(num);
        else
            rightMin.offer(num);

        // Rebalance heaps
        if (leftMax.size() > rightMin.size() + 1)
            rightMin.offer(leftMax.poll());
        else if (rightMin.size() > leftMax.size())
            leftMax.offer(rightMin.poll());
    }

    public double findMedian() {
        if (leftMax.size() == rightMin.size())
            return (leftMax.peek() + rightMin.peek()) / 2.0;
        return leftMax.peek();
    }
}
```

---

### ğŸ” Debug Example

```
add 1 â†’ left=[1], right=[]
add 2 â†’ left=[1], right=[2]
median = (1+2)/2=1.5
add 3 â†’ left=[2,1], right=[3]
median = 2
```

---

### âš™ï¸ Complexity

* Add: O(log n)
* Median: O(1)
* Space: O(n)

**Debug Tip:** print both heap contents after each insertion.

---

## ğŸ§© Summary Table â€” Heap / Priority Queue Problems

| # | Problem                 | Data Structure     | Key Idea            | Time       | Real-world Analogy    |
| - | ----------------------- | ------------------ | ------------------- | ---------- | --------------------- |
| 1 | Kth Largest Element     | Min-Heap           | Keep top k largest  | O(n log k) | Leaderboard           |
| 2 | Top K Frequent Elements | Min-Heap + HashMap | Keep top freq       | O(n log k) | Trending hashtags     |
| 3 | Merge K Sorted Lists    | Min-Heap           | Merge smallest head | O(N log K) | Merging logs          |
| 4 | Find Median from Stream | Two Heaps          | Balance halves      | O(log n)   | Live median analytics |

---

## ğŸ§­ Debugging Patterns

âœ… Always print heap contents after insertion/deletion
âœ… For two-heap median, check size balance after every `add()`
âœ… Visualize as two â€œbucketsâ€: smaller numbers (max-heap) | larger numbers (min-heap)

---

## ğŸ¯ Real-World Use Cases

* **Kth Largest:** Leaderboards, streaming analytics
* **Top K Frequent:** Recommender systems, trending analysis
* **Merge K Lists:** External merge sort, multi-file data merging
* **Median from Stream:** Real-time dashboards, IoT sensor median smoothing

---
